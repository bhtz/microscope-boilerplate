import{_ as e,o as t,c as i,X as a}from"./chunks/framework.4ab75e15.js";const m=JSON.parse('{"title":"Solution structure","description":"","frontmatter":{},"headers":[],"relativePath":"Architecture/solution-structure.md","filePath":"Architecture/solution-structure.md"}'),o={name:"Architecture/solution-structure.md"},n=a('<h1 id="solution-structure" tabindex="-1">Solution structure <a class="header-anchor" href="#solution-structure" aria-label="Permalink to &quot;Solution structure&quot;">​</a></h1><h2 id="services" tabindex="-1">Services <a class="header-anchor" href="#services" aria-label="Permalink to &quot;Services&quot;">​</a></h2><blockquote><p>Each service is a bounded context implemented by layered architecture solution</p></blockquote><h3 id="domain-layer" tabindex="-1">Domain Layer: <a class="header-anchor" href="#domain-layer" aria-label="Permalink to &quot;Domain Layer:&quot;">​</a></h3><blockquote><p>The Domain Layer is the core and most critical layer in Domain-Driven Design. It contains the heart of the business logic and represents the business domain. This layer focuses on encapsulating the business rules, behaviors, and concepts of the application. It consists of the following components:</p></blockquote><ul><li><strong>Domain Entities:</strong> Objects representing the core business concepts.</li><li><strong>Value Objects:</strong> Immutable objects representing descriptive aspects of the domain.</li><li><strong>Aggregates:</strong> Clusters of related objects treated as a single unit of consistency and transactional boundaries.</li><li><strong>Domain Services:</strong> Encapsulate domain logic that doesn&#39;t naturally fit within a single entity.</li><li><strong>Repositories:</strong> Provide an abstraction over data storage, allowing the application to interact with the persistence mechanism without knowing the underlying implementation.</li></ul><h3 id="application-layer" tabindex="-1">Application Layer: <a class="header-anchor" href="#application-layer" aria-label="Permalink to &quot;Application Layer:&quot;">​</a></h3><blockquote><p>The Application Layer sits on top of the Domain Layer and acts as an orchestrator of domain objects to fulfill user requests. It is responsible for coordinating the application&#39;s business workflows and handling user interactions. This layer contains application services that provide coarse-grained use cases, often mapped one-to-one with the use case requirements defined by the business. The application services collaborate with domain entities, value objects, and domain services from the Domain Layer to execute business logic, enforce business rules, and perform transactions.</p></blockquote><ul><li><strong>Mappings:</strong></li><li><strong>Behaviour:</strong></li><li><strong>Policies:</strong></li><li><strong>Features:</strong></li><li><strong>Application services:</strong></li></ul><h3 id="infrastructure-layer" tabindex="-1">Infrastructure Layer: <a class="header-anchor" href="#infrastructure-layer" aria-label="Permalink to &quot;Infrastructure Layer:&quot;">​</a></h3><blockquote><p>The Infrastructure Layer is responsible for providing technical implementations that support the Domain and Application Layers. It contains components that handle concerns like data persistence, messaging, caching, external integrations, and any other infrastructure-related services. Examples of infrastructure components are databases, data access repositories, message queues, email services, file storage systems, etc. This layer abstracts the underlying technologies from the rest of the application, allowing easy replacement or adaptation of technical components without impacting the core domain logic.</p></blockquote><ul><li><strong>Persistence configurations:</strong></li><li><strong>Repository implementation:</strong></li><li><strong>Migration scripts:</strong></li><li><strong>External services implementation:</strong></li></ul><h3 id="interface-layer" tabindex="-1">Interface Layer: <a class="header-anchor" href="#interface-layer" aria-label="Permalink to &quot;Interface Layer:&quot;">​</a></h3><blockquote><p>The Interface Layer is the outermost layer of the application and is responsible for handling communication with external systems and users. It provides various interfaces to interact with the application, such as user interfaces (web UI, mobile app UI), APIs (RESTful, GraphQL), command-line interfaces (CLI), and messaging interfaces. The Interface Layer translates user input into application requests and presents the application&#39;s output to users or external systems. This layer should be as thin as possible, delegating most of the business logic and processing to the Domain and Application Layers.</p></blockquote><ul><li><strong>Services configurations:</strong></li><li><strong>REST API:</strong></li><li><strong>GraphQL API:</strong></li><li><strong>Custom middlewares:</strong></li><li><strong>Interface services implementation:</strong></li></ul><h2 id="iac" tabindex="-1">IAC <a class="header-anchor" href="#iac" aria-label="Permalink to &quot;IAC&quot;">​</a></h2><blockquote><p>Infrastructure as Code (IAC) plays a pivotal role within the context of a microservices and Domain-Driven Design (DDD) solution architecture. IAC refers to the practice of defining and managing the underlying infrastructure, including servers, databases, networking, and more, through code-based configurations and scripts. IAC empowers development teams to provision, configure, and manage the diverse components of their distributed systems consistently and programmatically. By treating infrastructure as code, organizations can ensure scalability, maintainability, and reliability across their microservices ecosystem.</p></blockquote><ul><li><strong>docker-compose.yml:</strong></li><li><strong>init.sql :</strong></li></ul><h2 id="clients" tabindex="-1">Clients <a class="header-anchor" href="#clients" aria-label="Permalink to &quot;Clients&quot;">​</a></h2><h3 id="sdk" tabindex="-1">SDK <a class="header-anchor" href="#sdk" aria-label="Permalink to &quot;SDK&quot;">​</a></h3><blockquote><p>The SDK (Software Development Kit) layer represents a boundary between the clients layer and the services exposing REST and/or GraphQL APIs. Its primary objective is to encapsulate the complexities of interacting with these APIs, offering a simplified, uniform, and consistent interface to the clients (web, console, desktop, mobile, ...).</p></blockquote><p><strong>TodoApp GraphQL SDK:</strong></p><ul><li>Strawberry shake</li></ul><p><strong>TodoApp REST SDK:</strong></p><ul><li>Typescript</li><li>dotnet</li></ul><h3 id="web" tabindex="-1">Web <a class="header-anchor" href="#web" aria-label="Permalink to &quot;Web&quot;">​</a></h3><blockquote><p>The web application represents the user interface layer of the client-side. Whether it is a Single Page Application or a Progressive Web App, the focus is on delivering a rich and responsive user experience in the browser. The SPA architecture allows for dynamic content updates without reloading the entire page, while PWAs enable native-like capabilities such as offline access and push notifications.</p></blockquote><p><strong>Web Application (SPA / PWA):</strong></p><ul><li><strong>Configuration:</strong></li><li><strong>Pages:</strong></li><li><strong>Shared components:</strong></li><li><strong>Pages:</strong></li><li><strong>Settings:</strong></li></ul><h3 id="bff-backend-for-frontend" tabindex="-1">BFF (Backend For Frontend) <a class="header-anchor" href="#bff-backend-for-frontend" aria-label="Permalink to &quot;BFF (Backend For Frontend)&quot;">​</a></h3><blockquote><p>The Backend for Frontend is a design pattern where a dedicated backend service is created for each specific client application or type of client. It acts as an intermediary between the web application and the microservices, serving as a tailored API gateway for the client. The BFF pattern enables customizing data and functionalities to suit the exact requirements of the client, reducing unnecessary data transfers and minimizing the risk of over-fetching (aggregation call). By hosting the PWA, the BFF serves the static files and resources required for the client-side application to run in the user&#39;s browser. This hosting can be done using web servers or serverless infrastructure, depending on the application&#39;s needs and scalability requirements. Hosting the PWA on the BFF allows for better control over caching strategies, content delivery, and server-side configurations to enhance the application&#39;s performance and reliability. As the BFF interacts with various microservices to fetch data for the client application, it acts as a reverse proxy for the microservice API. This means that instead of the client directly communicating with the microservices, all API requests from the client are directed to the BFF, which then forwards those requests to the appropriate microservices.</p></blockquote><ul><li><strong>Blazor hosted:</strong></li><li><strong>YARP reverse proxy:</strong></li></ul><h3 id="cli" tabindex="-1">CLI <a class="header-anchor" href="#cli" aria-label="Permalink to &quot;CLI&quot;">​</a></h3><blockquote><p>A word for CLI client</p></blockquote><ul><li><strong>CLI:</strong></li><li><strong>Console GUI:</strong></li></ul><h3 id="mobile" tabindex="-1">Mobile <a class="header-anchor" href="#mobile" aria-label="Permalink to &quot;Mobile&quot;">​</a></h3><blockquote><p>A word for mobile client</p></blockquote><h2 id="documentation" tabindex="-1">Documentation <a class="header-anchor" href="#documentation" aria-label="Permalink to &quot;Documentation&quot;">​</a></h2><h3 id="documentation-as-code" tabindex="-1">Documentation as code <a class="header-anchor" href="#documentation-as-code" aria-label="Permalink to &quot;Documentation as code&quot;">​</a></h3><blockquote><p>The &quot;Documentation Layer&quot; revolutionizes the way we approach software project documentation. By writing solution documentation as code using Markdown, incorporating Mermaid for visualizations, and using VitePress to generate a web documentation portal, developers can foster a culture of up-to-date, accessible, and engaging documentation that grows alongside the project. Embrace the power of code-driven documentation and unlock the true potential of your software projects.</p></blockquote><h3 id="living-documentation" tabindex="-1">Living documentation <a class="header-anchor" href="#living-documentation" aria-label="Permalink to &quot;Living documentation&quot;">​</a></h3><p><strong>Product Discovery</strong></p><ul><li>Discovery discipline notes template</li></ul><p><strong>Architecture</strong></p><ul><li>Getting started guidelines</li><li>Event storming catalog</li><li>Architecture schema</li><li>Bounded context canvas <ul><li>Aggregate canvas</li></ul></li><li>Technology matrix guidelines</li></ul><p><strong>Organization &amp; Governance</strong></p><ul><li>Governance process templates <ul><li>Weekly meeting notes</li><li>Architecture Decision record</li></ul></li><li>Product engineering organization <ul><li>product engineering squad template</li></ul></li></ul><p><strong>Guidelines</strong></p><ul><li>Generic product engineering guidelines &amp; must-read you want to provide to the teams</li></ul><h2 id="additional-resources" tabindex="-1">Additional resources <a class="header-anchor" href="#additional-resources" aria-label="Permalink to &quot;Additional resources&quot;">​</a></h2><p><strong>Clean architecture</strong><img src="https://miro.medium.com/v2/resize:fit:800/1*0R0r00uF1RyRFxkxo3HVDg.png" alt=""></p><p><strong>Domain driven hexagon</strong><img src="https://user-images.githubusercontent.com/776825/144645528-e30234bd-088d-4066-845c-2e4bb3ed556e.png" alt=""></p>',52),r=[n];function s(l,c,u,d,h,p){return t(),i("div",null,r)}const f=e(o,[["render",s]]);export{m as __pageData,f as default};
